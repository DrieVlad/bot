2-1. Методе checkCity проверка вхождения слова в словарь сделана 
неэффективно. Вместо ArrayList<String> стоило бы хранить HashSet<String> 
(причем слова в множество сразу же помещаем в нижнем регистре), а затем 
делать проверку через метод contains(). А так получается классический 
пример того, как на ровном месте без каких-либо причин замедлить 
программу. :)

2-2. При чтении файлов с названиями городов нет смысла полагаться на 
именование файлов. Ведь, по идее, неважно, как файл называется. Все равно 
можем прочитать строчки с названиями городов и разместить их в хранилище 
(уж первую то букву названия города вычислить легко).
И привязка к именованиям файлов в файловой системе обычно нежелательна. 
Лучше уж тогда в программе явно прописать список файлов, которые должны 
быть доступны, а при чтении проверить доступность (иначе представим 
ситуацию, что по каким-то причинам один из файлов оказался удален, и 
ваша программа сейчас решит, что это нормально, хотя по факту часть базы 
городов будет утрачена).

Там же в коде работы с файлами ошибка обработки закрываемых объектов 
(метод close() должен вызываться из блока finally), но на это пока 
внимание не обращаю, поскольку мы обработку исключений еще не обсуждали.

И там же код чтения можно сделать чуть более устойчивым к особенностям 
строк в читаемых файлах (например, можно срезать начальные и концевые 
пробелы; начальные видны в редакторе, а вот концевые могут привести к 
неприятностям).

И там можно сразу же бороться с дубликатами (см. замечание выше, можно 
просто вместо ArrayList использовать HashSet). Но тут тонкий момент, 
поскольку затем этот набор слов используется для случайного выбора 
очередного города, и для текущей реализации такого выбора индексация в 
ArrayList важна.

2-3. Решение, которое сделано сейчас для получения помощи в любой момент, 
выглядит хрупким: нужно не забывать вызывать help(строка) для  анализа 
ввода пользователя. В данной задаче не буду к этому придираться, но надо 
подумать, как избавиться от этой проблемы во второй задаче.

