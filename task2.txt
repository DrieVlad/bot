2-1. Методе checkCity проверка вхождения слова в словарь сделана 
неэффективно. Вместо ArrayList<String> стоило бы хранить HashSet<String> 
(причем слова в множество сразу же помещаем в нижнем регистре), а затем 
делать проверку через метод contains(). А так получается классический 
пример того, как на ровном месте без каких-либо причин замедлить 
программу. :)

2-2. При чтении файлов с названиями городов нет смысла полагаться на 
именование файлов. Ведь, по идее, неважно, как файл называется. Все равно 
можем прочитать строчки с названиями городов и разместить их в хранилище 
(уж первую то букву названия города вычислить легко).
И привязка к именованиям файлов в файловой системе обычно нежелательна. 
Лучше уж тогда в программе явно прописать список файлов, которые должны 
быть доступны, а при чтении проверить доступность (иначе представим 
ситуацию, что по каким-то причинам один из файлов оказался удален, и 
ваша программа сейчас решит, что это нормально, хотя по факту часть базы 
городов будет утрачена).

Там же в коде работы с файлами ошибка обработки закрываемых объектов 
(метод close() должен вызываться из блока finally), но на это пока 
внимание не обращаю, поскольку мы обработку исключений еще не обсуждали.

И там же код чтения можно сделать чуть более устойчивым к особенностям 
строк в читаемых файлах (например, можно срезать начальные и концевые 
пробелы; начальные видны в редакторе, а вот концевые могут привести к 
неприятностям).

И там можно сразу же бороться с дубликатами (см. замечание выше, можно 
просто вместо ArrayList использовать HashSet). Но тут тонкий момент, 
поскольку затем этот набор слов используется для случайного выбора 
очередного города, и для текущей реализации такого выбора индексация в 
ArrayList важна.

2-3. Решение, которое сделано сейчас для получения помощи в любой момент, 
выглядит хрупким: нужно не забывать вызывать help(строка) для  анализа 
ввода пользователя. В данной задаче не буду к этому придираться, но надо 
подумать, как избавиться от этой проблемы во второй задаче.


2-4. Доработать структуру проекта: разделить каталоги с исходниками и 
бинарными файлами. Сейчас можно заметить, что в отдельных каталогах 
приходится добавлять файлы .gitignore, чтобы исключить из анализа 
изменений конкретные class-файлы. Так неудобно. Проще один раз настроить 
проект так, что исходники лежат в каталоге src, компиляция ведется в 
каталоге bin, а затем добавить в корневой .gitignore строчку:
/bin

2-5. В java есть готовый класс java.util.Stack. Соответственно, проще в 
FSMStack использовать сразу его.

2-6. В Runner есть такой вызов fsm.pushState(fsm::popState);
Кажется, что он просто лишний.

2-7. Если внимательно присмотреться к тому, как написаны функции действий, 
то в них обнаружится похожий код (пока не поясняю, какой), который можно 
из действий вообще убрать (перенести в код автомата).

2-8. В Runner ввод-вывод делается через обращения к статическим полям 
класса InOut. А зачем тогда абстракции вводили? Статические вызовы всегда 
вступают в конфликт с абстракциями.
И аналогично построена связка в классе Towns с классом Bot (Bot.bot.fsm) 
для доступа к автомату. В обоих случаях надо переделать связки без 
статических вызовов, а через нормальные зависимости классов (нужно 
передать необходимые сервисы подчиненному классу через его конструктор).

2-9. Замечаем, что в классах Runner и Towns получился дублирующий код, 
чтобы реагировать на ввод пользователя "помощь"/"устал"/"пока". 
Причем, если подумать, эти команды не относятся к игре в города. Ведь так? 
Это, скорее, глобальная специфика бота, которая относится к классу Runner.
Разумеется, надо подумать, как перестроить логику программы, чтобы эта 
часть кода не дублировалась.

2-10. В методах класса Towns слишком часто используется оператор continue, 
причем во многих случаях он просто не нужен. :) 
Надо разобраться, и оставить только те вхождения, где есть реальная 
необходимость.

2-11. Класс FileTownsReader. 
Попробуем подумать, в чем смысл метода getTowns()? Правильно, в подготовке 
данных класса (без них он работать не будет, ведь так?). А какой метод 
должен за это отвечать? Вспоминаем про конструктор.
То есть метод getTowns должен вызываться не из внешнего кода, а из 
конструктора. Причем в этом случае можно сделать параметром конструктора 
каталог, где размещаются данные о городах (для тестирования это может 
оказаться удобным).

2-12. Там же в классе FileTownsReader. Привыкаем к тому, что операции с 
файлами (чтение/запись потоков данных) обязаны находиться внутри блока 
try:

try (FileInputStream fstream = new FileInputStream(path + fileName))
{
  <код, использующий fstream>
}

Иначе можно получить ситуацию, когда файл окажется заблокированным для 
доступа.

