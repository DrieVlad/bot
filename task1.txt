1-1. Репозитарий Git должен быть устроен так, чтобы его содержимого было 
достаточно для компиляции проекта и его запуска. Но при этом не должно 
быть ничего лишнего. 

Отсюда выводы:
- для проекта в Eclipse в Git попадают:
  - каталог src (и иные каталоги с исходниками, если таковые есть)
  - файлы .classpath, .project и подобные с настройками проекта
При этом каталоги .metadata, .settings и bin в Git не вкладываются (в 
первом и втором находятся локальные настройки Eclipse и кэши плагинов, в 
последнем - откомпилированные файлы

- желательно иметь скрипт (cmd/bat для Windows или sh/bash для Linux), 
который умеет собирать программу без использования Eclipse.

В вашем случае нужно убрать из git (и добавить в .gitignore) содержимое 
каталога bin и каталоги .metadata и .settings

(done)

1-2. Внутри src есть еще какие-то файлы .classpath, .gitignore и .project
Надо навести порядок.

(done)

1-3. В тестах проверяются однотипные сценарии. Например, в Tests.testHelp, 
как я понимаю, проверяется, что бот понимает команду о помощи. И видим 
серию однотипных проверок. То есть дублирование кода более 2 раз.

Соответственно, напрашивается такая организация кода: все варианты теста, 
где ожидается ответ true, помещаем в массив, который затем в цикле 
обрабатываем. Аналогично для ответов false. Код теста станет проще и 
понятнее.

(done)

1-4. В AccessoryTowns есть проверки на то, что слово оканчивается на 
некоторую строку. Тут, во-первых, не хватает проверки, что слово имеет 
длину большую 2 (если вдруг это не так, будет ошибка периода исполнения). 
А во-вторых, у класса String есть метод endsWith, который уже как раз 
реализует нужную операцию.

(done)

Наблюдение: теперь видим повторение операции endsWith(буква). И снова это 
неэффективный код. Я бы построил код так:
- выставить i на индекс последней буквы в слове
- пока не вычислена искомая "последняя буква"
-- взяли в качестве последней букву по индексу i (через substring)
-- проверили, лежит ли эта буква в хэш-таблице "запрещенных" (т.е. ьйыъё)
-- если не лежит, вернули ее
-- иначе уменьшили i на единицу, конец цикла.

Такой код автоматически учитывает все необходимые условия и проверяет, что 
буква является запрещенной быстро.
 

1-5. Зачем вообще метод называется check? Почему было не сделать метод 
getLastSignificantLetter, который бы по слову сам выбирал, какую букву 
вернуть (последнюю, предпоследнюю, предпредпоследнюю)?

(done)

1-7. Нужно будет обсудить на занятии, почему решили передавать в 
checkWordDictionary множество использованных городов извне.

1-8. Также нужно будет обсудить, почему выбраны имена DataReader и 
DataWriter. Они неудачные, поскольку работают только со строками, а не с 
произвольными данными. Поэтому хотелось бы услышать вашу мотивацию. 

(done)

1-9. Почему метод checkData является частью DataReader? Разве это операция, 
которая специфична для источника данных? Ну и из описания операции совсем 
не очевидно, что она должна делать.

Замечание: операция ушла в default-реализацию в StringDataReader. Но она 
по-прежнему никак не связана с этим интерфейсом (и это правильно). Поэтому 
внедрение ее через default-метод выглядит странным. Лучше перенести ее в 
отдельный класс, который будет отвечать за проверку ввода пользователя.
(отмечу, что проверка ввода пользователя - это другая ответственность, 
нежели ввод данных пользователя).

Ну и название метода по-прежнему не отражает того, что он реально делает 
(слово check, т.е. "проверить", слишком общее; нужно выбрать более точное 
слово, если не получится - обсудить)

(not finished yet)

1-10. В InOut не надо постоянно пересоздавать Scanner. Его нужно создать 
один раз при инициализации класса, а затем переиспользовать. В текущей 
версии кода здесь можем словить ошибку, связанную с буферизацией ввода 
(новый Scanner будет не в курсе, что старый Scanner уже что-то прочитал из 
буфера). Ну и еще (на будущее) замечу, что класс InOut получается 
закрываемым, поскольку по сути управляет закрываемыми объектами (потоки 
ввода/вывода, сканер).

(done)

Наблюдение на будущее: название InOut не отражает ответственность класса. 
Сформулируйте ее по-русски, и тогда можно будет дать нормальное название.

1-11. По-моему, я уже обращал внимание на то, что бесконечные циклы - это 
зло. В любом случае нужно вводить флаг, позволяющий прерывать цикл при 
определенных условиях.

Замечание: в классе Bot по прежнему есть бесконечный цикл.

1-12. В классе Towns привязка логики к условию (i == 0) для определения, что 
ходит бот, не является удачным. Правильнее ввести переменную (например, 
botsTurn), которую вычислить один раз через условие i == 0, а затем уже 
использовать в логике кода (выбор сообщения и логика получения следующего 
города). 

(done)

Наблюдение:
Вот так код не пишут:
            boolean botsTurn = false;
            if (i == 0) 
            {
                botsTurn = true;
            }
Правильно, разумеется, так:
            boolean botsTurn = (i == 0);

Надо будет поправить.